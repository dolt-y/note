# 闭包（Closure）

---

## 一、闭包的定义

> 闭包是指**内层函数可以访问其外层函数的作用域，即使外层函数已经执行完毕**。

核心思想：**函数 + 外层作用域变量 = 持久化的私有状态**。

---

## 二、闭包的核心特性

1. **函数嵌套**  
   - 内层函数必须定义在外层函数内部。  

2. **访问外层变量**  
   - 内层函数可以读取和修改外层函数的局部变量。  

3. **延长变量生命周期**  
   - 外层变量不会因为外层函数执行结束而被回收，只要闭包存在。  

4. **私有作用域**  
   - 外部无法直接访问闭包内部的变量，实现数据封装。

---

## 三、闭包的用途

1. **防抖 / 节流**  
   - 保存定时器状态，限制函数执行频率。  

2. **计数器 / 累加器**  
   - 闭包保存私有计数状态。  

3. **数据封装 / 模块化**  
   - 闭包内部变量成为私有属性，只暴露接口函数。  

4. **缓存 / memoization**  
   - 保存函数计算结果，避免重复计算。

5. **事件处理状态保存**  
   - 保存按钮或 DOM 元素状态。

---

## 四、闭包的实现方式

### 1. 基本闭包
```js
function outer() {
  let count = 0;
  return function inner() {
    count++;
    console.log(count);
  }
}

const fn = outer();
fn(); // 1
fn(); // 2
```

### 2. 立即执行函数表达式 (IIFE)

```js
(function() {
  let count = 0;
  function inner() {
    count++;
    console.log(count);
  }
  inner();
})();
```

### 3.防抖函数

```js
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  }
}
```

### 4.非闭包实现（类 / 对象状态）

```js
class Debouncer {
  constructor(func, wait) {
    this.func = func;
    this.wait = wait;
    this.timeout = null;
  }
  run(...args) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.func(...args), this.wait);
  }
}
```

### 5.闭包类似OOP

| 特性   | 闭包       | OOP 类/对象       |
| ---- | -------- | -------------- |
| 状态存储 | 外层函数变量   | 实例属性           |
| 方法访问 | 内层函数操作状态 | 对象方法操作属性       |
| 私有性  | 自然私有     | 可用 `#` 或闭包实现私有 |
| 生命周期 | 闭包函数存在期间 | 实例存在期间         |
本质：闭包 = 私有状态 + 方法，类似类的实例属性 + 方法。

### 六、闭包的内存管理

闭包延长变量生命周期

外层变量被闭包引用，即使外层函数执行结束也不会被 GC 回收。

垃圾回收条件

闭包函数没有任何引用

没有其他闭包或对象引用外层作用域

可能导致内存泄漏的情况

闭包长期保存大对象或 DOM

定时器未清理

事件绑定未解绑

优化建议

避免闭包中保存不必要的大对象

手动解除事件绑定和定时器

组件卸载时清理闭包引用

### 七、闭包在前端框架中的应用

- Vue

防抖、节流、计数器等闭包状态绑定在函数内部

生命周期绑定：

组件存在 → 闭包存在

组件销毁 → 闭包可回收

注意：闭包引用 DOM 或大对象时需手动断开引用

- React Hook

函数组件每次渲染可能生成新的闭包

防抖、节流、定时器状态绑定闭包

组件卸载 → useEffect 清理函数执行 → 闭包可回收