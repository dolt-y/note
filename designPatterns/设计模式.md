# 设计模式

## 一、创建型模式（Creational Patterns）

- **工厂模式（Factory Pattern）**  
  创建对象时，通过工厂方法而不是直接创建对象，解耦客户端与具体类。

- **抽象工厂模式（Abstract Factory Pattern）**  
  提供创建一系列相关或相互依赖对象的接口，而无需指定具体类，实现对象族的生产。

- **单例模式（Singleton Pattern）**  
  确保一个类只有一个实例，并提供一个全局访问点。

- **建造者模式（Builder Pattern）**  
  将复杂对象的构建与表示分离，使得同样的构建过程可以创建不同表示的对象。

- **原型模式（Prototype Pattern）**  
  通过复制已有对象创建新对象，而不是重新实例化，便于对象的快速创建。

---

## 二、结构型模式（Structural Patterns）

- **适配器模式（Adapter Pattern）**  
  将一个类的接口转换成客户期望的接口，使原本不兼容的类可以一起工作。

- **桥接模式（Bridge Pattern）**  
  将抽象部分与实现部分分离，使它们可以独立变化，提高系统的扩展性。

- **组合模式（Composite Pattern）**  
  将对象组合成树形结构表示“整体-部分”关系，使客户端可以统一对待单个对象和组合对象。

- **装饰器模式（Decorator Pattern）**  
  动态地给对象添加额外的职责或功能，而不影响其他对象。

- **外观模式（Facade Pattern）**  
  为子系统提供一个统一的接口，简化客户端的使用。

- **享元模式（Flyweight Pattern）**  
  通过共享尽可能多的对象来减少内存消耗，适用于大量相似对象的场景。

---

## 三、行为型模式（Behavioral Patterns）

- **责任链模式（Chain of Responsibility Pattern）**  
  使多个对象都有机会处理请求，将请求沿着链传递，直到有对象处理它。

- **命令模式（Command Pattern）**  
  将请求封装成对象，从而使你可用不同的请求对客户进行参数化、队列化或记录请求日志。

- **解释器模式（Interpreter Pattern）**  
  给定一种语言，定义它的文法表示，并定义一个解释器来解释句子中的语法规则。

- **迭代器模式（Iterator Pattern）**  
  提供一种方法顺序访问集合对象中的元素，而又不暴露其内部表示。

- **中介者模式（Mediator Pattern）**  
  用一个中介对象来封装一系列对象的交互，使对象之间不需要直接引用，从而降低耦合。

- **备忘录模式（Memento Pattern）**  
  在不破坏封装性的前提下，捕获对象的内部状态，并在需要时恢复它。

- **观察者模式（Observer Pattern）**  
  当对象状态发生变化时，所有依赖于它的对象都得到通知并自动更新。

- **状态模式（State Pattern）**  
  允许对象在内部状态改变时改变行为，使对象看起来像改变了类。

- **策略模式（Strategy Pattern）**  
  定义一系列算法，将每一个算法封装起来，并使它们可以互换，客户端可以根据需要选择。

- **模板方法模式（Template Method Pattern）**  
  定义一个操作的骨架，将一些步骤延迟到子类实现，使子类可以在不改变整体结构的情况下重新定义部分步骤。

- **访问者模式（Visitor Pattern）**  
  封装作用于某种数据结构中的各元素的操作，允许在不改变数据结构的前提下增加新的操作。
